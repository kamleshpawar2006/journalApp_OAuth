--- START: main\java\net\engineeringdigest\journalApp\config\BasicSecurityConfig.java ---
package net.engineeringdigest.journalApp.config;

import net.engineeringdigest.journalApp.filter.JwtFilter;
import net.engineeringdigest.journalApp.security.OAuth2LoginSuccessHandler;
import net.engineeringdigest.journalApp.service.UserDetailsImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class BasicSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsImpl userDetailsImpl;

    @Autowired
    private OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;

    @Autowired
    private JwtFilter jwtFilter;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/journal/**", "/user/**").authenticated()
                .anyRequest().permitAll()
                .and()
                .oauth2Login(oauth -> oauth
                        .loginPage("/login")
                        .successHandler(oAuth2LoginSuccessHandler)
                );
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().csrf().disable().cors();
        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsImpl).passwordEncoder(passwordEncoderFun());
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoderFun() {
        return new BCryptPasswordEncoder();
    }
}

--- END: main\java\net\engineeringdigest\journalApp\config\BasicSecurityConfig.java ---

--- START: main\java\net\engineeringdigest\journalApp\config\DatabaseChecker.java ---
package net.engineeringdigest.journalApp.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.sql.Connection;

@Slf4j
@Component
public class DatabaseChecker {

    private final DataSource dataSource;

    public DatabaseChecker(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @PostConstruct
    public void testConnection() {
        try (Connection connection = dataSource.getConnection()) {
            log.info("Database connected successfully!");
        } catch (Exception e) {
            log.error("Database connection failed!");
            e.printStackTrace();
        }
    }
}


--- END: main\java\net\engineeringdigest\journalApp\config\DatabaseChecker.java ---

--- START: main\java\net\engineeringdigest\journalApp\config\DataSourceConfig.java ---
package net.engineeringdigest.journalApp.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();

        String url = "jdbc:mysql://localhost:3306/journal";
        String username = System.getProperty("db.username");
        String password = System.getProperty("db.password");

        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");

        return dataSource;
    }
}
--- END: main\java\net\engineeringdigest\journalApp\config\DataSourceConfig.java ---

--- START: main\java\net\engineeringdigest\journalApp\config\GlobalCorsConfig.java ---
package net.engineeringdigest.journalApp.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class GlobalCorsConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**") // allow all endpoints
                        .allowedOrigins("http://localhost:4200") // allow Angular dev server
                        .allowedHeaders("Authorization", "Content-Type")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }
}


--- END: main\java\net\engineeringdigest\journalApp\config\GlobalCorsConfig.java ---

--- START: main\java\net\engineeringdigest\journalApp\controller\FrontendController.java ---
//package net.engineeringdigest.journalApp;
//
//import org.springframework.stereotype.Controller;
//import org.springframework.web.bind.annotation.RequestMapping;
//
//@Controller
//public class FrontendController {
//
//    @RequestMapping(value = {
//            "/",
//            "/{path:[^\\.]*}",
//            "/**/{path:[^\\.]*}"
//    })
//    public String forwardAngularRoutes() {
//        return "forward:/index.html";
//    }
//
//}
--- END: main\java\net\engineeringdigest\journalApp\controller\FrontendController.java ---

--- START: main\java\net\engineeringdigest\journalApp\controller\JournalController.java ---
package net.engineeringdigest.journalApp.controller;

import lombok.extern.slf4j.Slf4j;
import net.engineeringdigest.journalApp.entity.JournalEntity;
import net.engineeringdigest.journalApp.entity.UserEntity;
import net.engineeringdigest.journalApp.exception.ResourceNotFoundException;
import net.engineeringdigest.journalApp.service.JournalService;
import net.engineeringdigest.journalApp.service.UserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequestMapping("/journal")
public class JournalController {

    @Autowired
    private JournalService journalService;

    @Autowired
    private UserService userService;

    private List<JournalEntity> journalEntities = new ArrayList<>();

    @GetMapping
    public ResponseEntity<List<JournalEntity>> journalEntries() {
        return new ResponseEntity<>(journalService.getAllJournalEntries(), HttpStatus.OK);
    }

    @GetMapping("/user")
    public ResponseEntity<List<JournalEntity>> journalEntriesByUserName() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity user = userService.findByUserName(authentication.getName());
        List<Integer> journalEntriesIDs = user.getJournalEntries();
        if(journalEntriesIDs != null && journalEntriesIDs.size() > 0) {
            List<JournalEntity> journalEntities = journalService.getJournalEntriesByIDs(journalEntriesIDs);
            return new ResponseEntity<>(journalEntities, HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }
    }

    @GetMapping("/search")
    public ResponseEntity<?> journalEntriesByCriteria(@RequestParam String criteria, @RequestParam String criteriaValue) {
        List<JournalEntity> result;

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity user = userService.findByUserName(authentication.getName());
        List<Integer> journalEntriesIDs = user.getJournalEntries();

        switch (criteria)  {
            case "id" : {
                try {
                    Integer journalId = Integer.parseInt(criteriaValue);
                    if(journalEntriesIDs.contains(journalId)) {
                        result = journalService.getJournalEntity(journalId);
                    } else {
                        return new ResponseEntity<>("Unauthorised Journal Entry", HttpStatus.BAD_REQUEST);
                    }
                } catch (NumberFormatException ex) {
                    return new ResponseEntity<>("Invalid search value", HttpStatus.BAD_REQUEST);
                }
                break;
            }
            case "title" : {
                result = journalService.getJournalEntity(criteriaValue);
                break;
            }
            default: {
                return new ResponseEntity<>("Invalid search criteria", HttpStatus.BAD_REQUEST);
            }
        }
        return new ResponseEntity<>(result, (!result.isEmpty()) ? HttpStatus.OK : HttpStatus.NOT_FOUND);
    }

    @PostMapping
    public ResponseEntity<?> addJournal(@RequestBody JournalEntity journalEntity) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity user = userService.findByUserName(authentication.getName());
        Integer insertedId;
        try {
            insertedId = journalService.save(journalEntity, user.getUserName());
            journalEntity.setId(insertedId);
            return new ResponseEntity<>(journalEntity, HttpStatus.OK);
        } catch (ResourceNotFoundException ex) {
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
        }
    }

    @PostMapping("/save-all-journals")
    public ResponseEntity<?> addAllJournal(@RequestBody List<JournalEntity> journalEntities) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return new ResponseEntity<>(journalService.saveAll(journalEntities, authentication.getName()), HttpStatus.OK);
    }

    @PutMapping
    public ResponseEntity<?> updateJournal(@RequestBody List<JournalEntity> journalEntityList) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity user = userService.findByUserName(authentication.getName());
        if(authentication.getName() != null && journalEntityList.size() > 0) {
            try {
                List<Integer> journalEntriesIDs = user.getJournalEntries();
                List<JournalEntity> authenticatedJournalList = journalEntityList.stream().filter(e -> journalEntriesIDs.contains(e.getId())).collect(Collectors.toList());
                List<JournalEntity> unAuthenticatedJournalList = journalEntityList.stream().filter(e -> !journalEntriesIDs.contains(e.getId())).collect(Collectors.toList());
                Map<String, List<Integer>> journalIDs = new HashMap<>();

                if(authenticatedJournalList.size() > 0) {
                    journalIDs.put("Authenticated Journal IDs", authenticatedJournalList.stream().map(e -> e.getId()).collect(Collectors.toList()));
                    journalService.updateAll(authenticatedJournalList);
                }
                if(unAuthenticatedJournalList.size() > 0) {
                    journalIDs.put("Unauthenticated Journal IDs", unAuthenticatedJournalList.stream().map(e -> e.getId()).collect(Collectors.toList()));
                }
                return new ResponseEntity<>(journalIDs, HttpStatus.OK);
            } catch (IllegalArgumentException ex) {
                log.error(String.valueOf(ex));
                return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
            } catch (Exception ex) {
                log.error(String.valueOf(ex));
                return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
            }
        } else {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteJournal(@PathVariable Integer id) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity user = userService.findByUserName(authentication.getName());
        List<Integer> journalEntriesIDs = user.getJournalEntries();
        if(journalEntriesIDs.contains(id)) {
            try {
                return new ResponseEntity<>(journalService.deleteJournal(id), HttpStatus.OK);
            } catch (RuntimeException ex) {
                log.error(ex.getMessage());
                return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
            }
        } else {
            return new ResponseEntity<>("Journal not found", HttpStatus.NOT_FOUND);
        }
    }

}

--- END: main\java\net\engineeringdigest\journalApp\controller\JournalController.java ---

--- START: main\java\net\engineeringdigest\journalApp\controller\UserController.java ---
package net.engineeringdigest.journalApp.controller;

import lombok.RequiredArgsConstructor;
import net.engineeringdigest.journalApp.entity.UserEntity;
import net.engineeringdigest.journalApp.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.*;

@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    public ResponseEntity<List<UserEntity>> getAllUsers() {
        List<UserEntity> users = userService.getAll();
        if(users.size() > 0) {
            return new ResponseEntity<>(users, HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }
    }

    @GetMapping("/{userName}")
    public ResponseEntity<UserEntity> getUserByName(@PathVariable String userName) {
        UserEntity user = userService.findByUserName(userName);
        if(user != null) {
            return new ResponseEntity<>(user, HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }
    }

    @PutMapping
    public ResponseEntity<HttpStatus> updateUser(@RequestBody UserEntity user) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserEntity userInDB = userService.findByUserName(authentication.getName());
        if(!userInDB.equals(null)) {
            userInDB.setPassword(user.getPassword());
            userService.saveUser(userInDB);
            return new ResponseEntity<>(HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<HttpStatus> deleteUser(@PathVariable Integer id) {
        try {
            UserEntity user = userService.findById(id);
            if(!user.equals(null)) {
                userService.deleteUser(id);
                return new ResponseEntity<>(HttpStatus.OK);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
        } catch (Exception ex) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }

    }

}

--- END: main\java\net\engineeringdigest\journalApp\controller\UserController.java ---

--- START: main\java\net\engineeringdigest\journalApp\controller\UserCreation.java ---
package net.engineeringdigest.journalApp.controller;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.RequiredArgsConstructor;
import net.engineeringdigest.journalApp.entity.UserEntity;
import net.engineeringdigest.journalApp.service.UserDetailsImpl;
import net.engineeringdigest.journalApp.service.UserService;
import net.engineeringdigest.journalApp.utility.JwtUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
@RestController
@RequestMapping("/user-registration")
public class UserCreation {

    private static final Logger log = LoggerFactory.getLogger(UserCreation.class);
    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    JwtUtil jwtUtil;

    @Autowired
    UserDetailsImpl userDetailsImpl;

    private static final PasswordEncoder myPasswordEncoder = new BCryptPasswordEncoder();

    @Autowired
    private final UserService userService;

    @PostMapping
    public ResponseEntity<UserEntity> createUser(@RequestBody UserEntity user) {
        return new ResponseEntity(userService.createUser(user), HttpStatus.OK);
    }

    @GetMapping("/validateJwt")
    public ResponseEntity<?> validateJwt() {
        Map<String, String> response = new HashMap<>();
        try {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            UserEntity userInDB = userService.findByUserName(authentication.getName());
            if(userInDB != null) {
                response.put("name", userInDB.getName());
                response.put("email", userInDB.getEmail());
                response.put("profileImage", userInDB.getProfilePicture());
                response.put("status", "Valid Token");
            } else {
                response.put("status", "Invalid User");
            }
            return new ResponseEntity<>(response, HttpStatus.OK);
        } catch (Exception ex) {
            response.put("status", "Invalid Token");
            return new ResponseEntity<>(ex, HttpStatus.UNAUTHORIZED);
        }
    }

    @PostMapping("/login")
    public ResponseEntity<?> loginUser(@RequestBody UserEntity user) {
        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword())
            );
            UserEntity dbUser = userService.findByUserName(user.getUserName());
            UserDetails userDetails = userDetailsImpl.loadUserByUsername(user.getUserName());
            String jwt = jwtUtil.generateToken(userDetails, dbUser.getUserId());
            return new ResponseEntity<>(jwt, HttpStatus.OK);
        } catch (Exception ex) {
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.UNAUTHORIZED);
        }
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<?> refreshToken(@RequestHeader("Authorization") String authHeader) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Missing Authorization header");
        }

        String token = authHeader.substring(7);

        try {
            if (jwtUtil.isTokenExpired(token)) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Expired refresh token");
            }
        } catch (ExpiredJwtException ex) {
            log.error(ex.getMessage());
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.UNAUTHORIZED);
        } catch (Exception ex) {
            log.error(ex.getMessage());
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }

        String tokenType = jwtUtil.extractTokenType(token);
        if (!"REFRESH".equals(tokenType)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid token type");
        }

        String username = jwtUtil.extractUsername(token);
        UserDetails userDetails = userDetailsImpl.loadUserByUsername(username);
        String newAccessToken = jwtUtil.generateToken(userDetails, null);
        String newRefreshToken = jwtUtil.generateRefreshToken(username);

        Map<String, String> tokens = new HashMap<>();
        tokens.put("accessToken", newAccessToken);
        tokens.put("refreshToken", newRefreshToken);
        return ResponseEntity.ok(tokens);
    }

}

--- END: main\java\net\engineeringdigest\journalApp\controller\UserCreation.java ---

--- START: main\java\net\engineeringdigest\journalApp\exception\ResourceNotFoundException.java ---
package net.engineeringdigest.journalApp.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

--- END: main\java\net\engineeringdigest\journalApp\exception\ResourceNotFoundException.java ---

--- START: main\java\net\engineeringdigest\journalApp\filter\JwtFilter.java ---
package net.engineeringdigest.journalApp.filter;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import net.engineeringdigest.journalApp.service.UserDetailsImpl;
import net.engineeringdigest.journalApp.utility.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    UserDetailsImpl userDetailsImpl;

    // Skip filtering for refresh token endpoint
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.contains("/user-registration/refresh-token");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException, ExpiredJwtException, UsernameNotFoundException {
        String authorizationHeader = request.getHeader("Authorization");

        try {
            if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                String jwt = authorizationHeader.substring(7);

                Claims claims = jwtUtil.extractAllClaims(jwt);
                String tokenType = (String) claims.get("tokenType");

                // Only allow ACCESS tokens for regular API requests
                if (!"ACCESS".equals(tokenType)) {
                    throw new SecurityException("Token is not an access token");
                }

                String userName = jwtUtil.extractUsername(jwt);
                UserDetails userDetails = userDetailsImpl.loadUserByUsername(userName);

                List<SimpleGrantedAuthority> authorities = jwtUtil.extractRoles(jwt).stream()
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());

                if (!jwtUtil.isTokenExpired(jwt)) {
                    UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
                    auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    response.addHeader("hi", "test header text");
                    SecurityContextHolder.getContext().setAuthentication(auth);
                }
            }
            // Important: chain.doFilter has to stay inside try
            chain.doFilter(request, response);
        } catch (ExpiredJwtException ex) {
            // Catch token expiration separately
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            response.getWriter().write("{\"error\": \"Token expired. Please login again.\"}");
            response.getWriter().flush();
        } catch (Exception ex) {
            // Catch other exceptions (optional)
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            response.getWriter().write("{\"error\": \"Invalid token.\"}");
            response.getWriter().flush();
        }
    }

}

--- END: main\java\net\engineeringdigest\journalApp\filter\JwtFilter.java ---

--- START: main\java\net\engineeringdigest\journalApp\JournalApplication.java ---
package net.engineeringdigest.journalApp;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement
public class JournalApplication {

    public static void main(String[] args) {
        SpringApplication.run(JournalApplication.class, args);
    }


}
--- END: main\java\net\engineeringdigest\journalApp\JournalApplication.java ---

--- START: main\java\net\engineeringdigest\journalApp\security\OAuth2LoginSuccessHandler.java ---
package net.engineeringdigest.journalApp.security;

import lombok.RequiredArgsConstructor;
import net.engineeringdigest.journalApp.entity.UserEntity;
import net.engineeringdigest.journalApp.service.UserDetailsImpl;
import net.engineeringdigest.journalApp.service.UserService;
import net.engineeringdigest.journalApp.utility.JwtUtil;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class OAuth2LoginSuccessHandler implements AuthenticationSuccessHandler {

    private final JwtUtil jwtUtil;
    private final UserService userService;
    private final UserDetailsImpl userDetailsImpl;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {

        OAuth2AuthenticationToken token = (OAuth2AuthenticationToken) authentication;
        Map<String, Object> attributes = token.getPrincipal().getAttributes();
        String registrationId = token.getAuthorizedClientRegistrationId(); // "google" or "github"

        // Logging for debugging
        System.out.println("Login via: " + registrationId);
        attributes.forEach((key, value) -> System.out.println(key + " = " + value));

        String email = null;
        String name = null;
        String pictureUrl = null;

        // Provider-specific mapping
        if ("google".equals(registrationId)) {
            email = (String) attributes.get("email");
            name = (String) attributes.get("name");
            pictureUrl = (String) attributes.get("picture");
        } else if ("github".equals(registrationId)) {
            email = (String) attributes.get("email"); // May be null if email is private
            name = (String) attributes.get("name");
            pictureUrl = (String) attributes.get("avatar_url");

            // Fallback if name is null
            if (name == null) {
                name = (String) attributes.get("login"); // GitHub username
            }

            // Fallback if email is null (you may need a second API call to get email)
            if (email == null) {
                email = name + "@users.noreply.github.com"; // fallback dummy email
            }
        }

        // Check if user exists
        UserEntity user = userService.findByUserName(email);
        if (user == null) {
            user = new UserEntity();
            user.setUserName(email);
            user.setPassword(""); // OAuth doesn't use password
            user.setRoles("USER");
            user.setName(name);
            user.setEmail(email);
            user.setProfilePicture(pictureUrl);
            userService.createUser(user);
        } else {
            user.setName(name);
            user.setEmail(email);
            user.setProfilePicture(pictureUrl);
            userService.saveUser(user);
        }

        // Load UserDetails and generate JWT tokens
        UserDetails userDetails = userDetailsImpl.loadUserByUsername(email);
        String jwt = jwtUtil.generateToken(userDetails, user.getUserId());
        String refreshToken = jwtUtil.generateRefreshToken(email);

        // Redirect to frontend with token
        String redirectUrl = "http://localhost:4200/login?token=" + jwt + "&refresh=" + refreshToken;
        response.sendRedirect(redirectUrl);
    }
}

--- END: main\java\net\engineeringdigest\journalApp\security\OAuth2LoginSuccessHandler.java ---

--- START: main\java\net\engineeringdigest\journalApp\utility\JwtUtil.java ---
package net.engineeringdigest.journalApp.utility;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwt;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class JwtUtil {

    private final String SECRET_KEY = System.getProperty("jwt.secret");

    public String generateToken(UserDetails userDetails, Integer userId) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("roles", userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList()));
        claims.put("tokenType", "ACCESS");
        return createToken(claims, userDetails.getUsername(), 1000 * 60 * 15); // 15 minutes
    }

    public String generateRefreshToken(String userName) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("tokenType", "REFRESH");
        return createToken(claims, userName, 1000 * 60 * 30); // 30 minutes
    }

    private String createToken(Map<String, Object> claims, String userName, long expirationMillis) {
        return Jwts.builder()
                .claims(claims)
                .subject(userName)
                .header().add("type", "JWT")
                .and()
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + expirationMillis))
                .signWith(getSigningKey(), SignatureAlgorithm.HS512)
                .compact();
    }

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
    }

    public String extractUsername(String jwt) {
        return extractAllClaims(jwt).getSubject();
    }

    public String extractTokenType(String jwt) {
        return (String) extractAllClaims(jwt).get("tokenType");
    }

    private Date extractExpiration(String jwt) {
        return extractAllClaims(jwt).getExpiration();
    }

    public Boolean isTokenExpired(String jwt) {
        return extractExpiration(jwt).before(new Date());
    }

    public Claims extractAllClaims(String jwt) {
        return Jwts.parser()
                .setSigningKey(getSigningKey())
                .build()
                .parseSignedClaims(jwt)
                .getPayload();
    }

    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        return (List<String>) claims.get("roles");
    }

}

--- END: main\java\net\engineeringdigest\journalApp\utility\JwtUtil.java ---

